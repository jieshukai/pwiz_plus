import datetime
import os
import peewee

from pwiz_plus.relection import PwizIntrospector, DATABASE_MAP

TEMPLATE = """
from peewee import *%s

database = %s('%s', **%s)


class BaseModel(Model):
    class Meta:
        database = database
"""


class BaseMakeModels(object):
    # 头部标记

    def __init__(self, db_type, db_name, tables, **kwargs):
        self.tables = tables
        self.db_type = db_type
        self.db_name = db_name
        self.conn = peewee.MySQLDatabase(self.db_name, **kwargs)
        self.kwargs = kwargs
        if db_type not in DATABASE_MAP:
            raise Exception('Unrecognized database, must be one of: %s' % ', '.join(DATABASE_MAP.keys()))
        schema = kwargs.pop('schema', None)
        DatabaseClass = DATABASE_MAP[db_type]
        db = DatabaseClass(db_name, **kwargs)
        self.introspector = PwizIntrospector.from_database(db, schema=schema)
        self.database = self.introspector.introspect(table_names=tables)
        self.content = []

    def add_content(self, line):
        self.content.append(line)

    def add_header(self, user='jieshukai'):
        print_ = self.add_content
        timestamp = datetime.datetime.now()
        print_('# Code generated by:')
        print_('# author: %s' % user)
        print_('# Date: %s' % timestamp.strftime('%Y-%M-%d %H:%M:%S'))
        print_('# Database: %s' % self.introspector.get_database_name())
        print_('# Peewee version: %s' % peewee.__version__)
        print_(TEMPLATE % (
            self.introspector.get_additional_imports(),
            self.introspector.get_database_class().__name__.replace('Pwiz', ''),
            self.introspector.get_database_name(),
            repr(self.introspector.get_database_kwargs())))

    def get_content(self):
        self.add_header()
        return '\n'.join(self.content)


class MysqlMakeModels(BaseMakeModels):
    """
    简化版
    1. 无外键
    2. 无scheme
    3. 无多个主键或无主键：
    """

    # 正文输出
    def print_models(self, introspector, tables=None, preserve_order=False):
        print_ = self.add_content

        def _print_table(table, seen):
            # 正文model
            print_('\nclass %s(BaseModel):' % self.database.model_names[table])
            columns = self.database.columns[table].items()
            # 排序
            if not preserve_order:
                columns = sorted(columns)
            primary_keys = self.database.primary_keys[table]
            for name, column in columns:
                skip = all([
                    name in primary_keys,
                    name == 'id',
                    len(primary_keys) == 1,
                    column.field_class in introspector.pk_classes])
                if skip:
                    continue
                if column.primary_key and len(primary_keys) > 1:
                    column.primary_key = False
                print_('    %s' % column.get_field())

            print_('')
            # 表名称
            print_('    class Meta:')
            print_('        db_table = \'%s\'' % table)
            # 混合索引
            multi_column_indexes = self.database.multi_column_indexes(table)
            if multi_column_indexes:
                print_('        indexes = (')
                for fields, unique in sorted(multi_column_indexes):
                    print_('            ((%s), %s),' % (
                        ', '.join("'%s'" % field for field in fields),
                        unique,
                    ))
                print_('        )')

            print_('')
            seen.add(table)

        seen = set()
        for table in sorted(self.database.model_names.keys()):
            if table not in seen:
                if not tables or table in tables:
                    _print_table(table, seen)
        # init 中 model 字典
        tables_dict = ['{']
        for k, v in self.database.model_names.items():
            tables_dict.append("'{}': {},".format(k, v))
        print_('\n{} = {}'.format(self.db_name, '\n    '.join(tables_dict) + '\n}'))

    def get_content(self, add_header=True, preserve_order=False):
        if add_header:
            self.add_header()
        self.print_models(self.introspector, self.tables, preserve_order=False)
        return '\n'.join(self.content)


class CreateModels(object):
    def get_file_path(self, file_path):
        file_dir = None
        win_split = file_path.split('\\')
        linux_split = file_path.split('/')
        if len(linux_split) > 1 and len(win_split) == 1:
            file_dir = '/'.join(file_path.split('/')[:-1])
        if len(win_split) > 1 and len(linux_split) == 1:
            file_dir = '\\'.join(file_path.split('\\')[:-1])
        if file_dir:
            if not os.path.exists(file_dir):
                os.makedirs(file_dir)
                open(os.path.join(file_dir, '__init__.py'), 'wb').close()
                open(os.path.join(os.path.dirname(file_dir), '__init__.py'), 'wb').close()
            return file_path
        else:
            raise Exception('dir error,place use os.path.join')

    def write_sql_content(self, conn, tables, path):
        if tables is None:
            tables = conn.get_tables()
        table_sqls = [conn.execute_sql('show create table {} '.format(table)).fetchone() for table in tables]

        with open(path, 'wb') as f:
            for table_sql in table_sqls:
                for index, line in enumerate(table_sql):
                    if index == 0:
                        f.write(b'-- %s \n' % bytes(line.encode()))
                    else:
                        f.write(bytes(line.encode()) + b'\n')
                f.write(b'\n')

    def write_py_content(self, model_path, model_content):
        with open(model_path, 'wb') as f:
            f.write(bytes(model_content.encode()))
